#!/usr/bin/env python
"""Generate Pydantic models from OpenResponses OpenAPI specification.

This script downloads the OpenResponses OpenAPI spec, detects changes,
and regenerates Pydantic models when the spec has been updated.

Usage:
    python scripts/generate_types.py [--force] [--check] [--version]

Options:
    --force     Regenerate even if spec hasn't changed
    --check     Check if spec has changed without regenerating (exit 1 if changed)
    --version   Show current spec hash and exit
"""

import argparse
import hashlib
import re
import subprocess
import sys
import urllib.request
from pathlib import Path

OPENRESPONSES_SPEC_URL = (
    "https://raw.githubusercontent.com/openresponses/openresponses/main/public/openapi/openapi.json"
)
PROJECT_ROOT = Path(__file__).parent.parent
SPEC_CACHE_DIR = PROJECT_ROOT / "src" / "openresponses_types" / "_spec_cache"
SPEC_CACHE_FILE = SPEC_CACHE_DIR / "openapi.json"
SPEC_HASH_FILE = SPEC_CACHE_DIR / "openapi.sha256"
OUTPUT_FILE = PROJECT_ROOT / "src" / "openresponses_types" / "types.py"
INIT_FILE = PROJECT_ROOT / "src" / "openresponses_types" / "__init__.py"

GENERATION_HEADER = '''\
"""Auto-generated Pydantic models from OpenResponses OpenAPI specification.

DO NOT EDIT THIS FILE MANUALLY.

This file is generated by: scripts/generate_types.py
Source: {spec_url}
Spec Hash: {spec_hash}

To regenerate:
    uv run python scripts/generate_types.py --force
"""

'''


def fetch_spec() -> bytes:
    """Fetch the OpenResponses OpenAPI spec from the remote URL."""
    print(f"Fetching OpenAPI spec from {OPENRESPONSES_SPEC_URL}...")
    with urllib.request.urlopen(OPENRESPONSES_SPEC_URL, timeout=30) as response:  # noqa: S310
        return response.read()


def compute_hash(content: bytes) -> str:
    """Compute SHA-256 hash of content."""
    return hashlib.sha256(content).hexdigest()


def get_cached_hash() -> str | None:
    """Get the previously stored spec hash, if any."""
    if SPEC_HASH_FILE.exists():
        return SPEC_HASH_FILE.read_text().strip()
    return None


def save_spec_cache(content: bytes, spec_hash: str) -> None:
    """Save the spec and its hash to the cache directory."""
    SPEC_CACHE_DIR.mkdir(parents=True, exist_ok=True)
    SPEC_CACHE_FILE.write_bytes(content)
    SPEC_HASH_FILE.write_text(spec_hash)


def fix_discriminator_issues() -> None:
    """Remove discriminator annotations that cause Pydantic errors.

    datamodel-codegen generates discriminator annotations with StrEnum types,
    but Pydantic requires Literal types for discriminators. This function
    removes the discriminator annotations to avoid runtime errors.
    """
    print("Fixing discriminator compatibility issues...")

    content = OUTPUT_FILE.read_text()

    # Remove discriminator="..." from Field() calls
    content = re.sub(r',\s*discriminator=["\'][^"\']+["\']', "", content)
    content = re.sub(r'discriminator=["\'][^"\']+["\']\s*,\s*', "", content)

    # Remove standalone Field(discriminator=...) - just the argument
    content = re.sub(r'Field\(discriminator=["\'][^"\']+["\']\)', "Field()", content)

    # Remove Annotated[Type, Field()] -> Type (empty Field is useless)
    content = re.sub(r"Annotated\[([^,\[\]]+(?:\[[^\]]*\])?),\s*Field\(\)\s*\]", r"\1", content)

    OUTPUT_FILE.write_text(content)


def format_output() -> None:
    """Format the generated file with ruff."""
    print("Formatting with ruff...")

    # Fix lint issues (import sorting, trailing newline, etc.)
    fix_cmd = ["ruff", "check", "--fix", str(OUTPUT_FILE)]
    subprocess.run(fix_cmd, capture_output=True, text=True, check=False)

    # Format the file
    format_cmd = ["ruff", "format", str(OUTPUT_FILE)]
    result = subprocess.run(format_cmd, capture_output=True, text=True, check=False)

    if result.returncode != 0:
        print(f"Warning: ruff formatting failed: {result.stderr}", file=sys.stderr)


def generate_models(spec_hash: str) -> None:
    """Run datamodel-codegen to generate Pydantic models."""
    print("Generating Pydantic models...")

    cmd = [
        "datamodel-codegen",
        "--input",
        str(SPEC_CACHE_FILE),
        "--input-file-type",
        "openapi",
        "--output-model-type",
        "pydantic_v2.BaseModel",
        "--use-annotated",
        "--field-constraints",
        "--target-python-version",
        "3.11",
        "--use-double-quotes",
        "--collapse-root-models",
        "--output",
        str(OUTPUT_FILE),
    ]

    result = subprocess.run(cmd, capture_output=True, text=True, check=False)

    if result.returncode != 0:
        print(f"Error generating models: {result.stderr}", file=sys.stderr)
        sys.exit(1)

    prepend_header(spec_hash)
    fix_discriminator_issues()
    format_output()
    update_init_spec_hash(spec_hash)
    print(f"Generated: {OUTPUT_FILE}")


def prepend_header(spec_hash: str) -> None:
    """Prepend generation header to the output file."""
    content = OUTPUT_FILE.read_text()
    header = GENERATION_HEADER.format(spec_url=OPENRESPONSES_SPEC_URL, spec_hash=spec_hash)

    lines = content.split("\n")
    filtered_lines = []
    skip_header = True
    for line in lines:
        if skip_header and (line.startswith(("#", '"""')) or not line.strip()):
            if line.startswith('"""'):
                skip_header = False
            continue
        filtered_lines.append(line)

    OUTPUT_FILE.write_text(header + "\n".join(filtered_lines))


def update_init_spec_hash(spec_hash: str) -> None:
    """Update the __spec_hash__ in __init__.py."""
    if not INIT_FILE.exists():
        return

    content = INIT_FILE.read_text()
    # Update __spec_hash__ if it exists
    if "__spec_hash__" in content:
        content = re.sub(r'__spec_hash__\s*=\s*"[^"]*"', f'__spec_hash__ = "{spec_hash}"', content)
        INIT_FILE.write_text(content)


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate OpenResponses types from OpenAPI spec")
    parser.add_argument("--force", action="store_true", help="Regenerate even if spec hasn't changed")
    parser.add_argument(
        "--check", action="store_true", help="Check if spec has changed without regenerating (exit 1 if changed)"
    )
    parser.add_argument("--version", action="store_true", help="Show current spec hash and exit")
    args = parser.parse_args()

    if args.version:
        cached_hash = get_cached_hash()
        if cached_hash:
            print(f"Current spec hash: {cached_hash}")
        else:
            print("No spec hash cached yet. Run without --version to generate.")
        return

    spec_content = fetch_spec()
    current_hash = compute_hash(spec_content)
    cached_hash = get_cached_hash()

    if cached_hash == current_hash and not args.force:
        print(f"OpenResponses spec unchanged (hash: {current_hash[:12]}...)")
        if args.check:
            sys.exit(0)
        print("Use --force to regenerate anyway.")
        return

    if cached_hash is None:
        print("First time generating OpenResponses types.")
    else:
        print("OpenResponses spec has CHANGED!")
        print(f"  Previous: {cached_hash[:12]}...")
        print(f"  Current:  {current_hash[:12]}...")

    if args.check:
        print("\nSpec change detected. Run without --check to regenerate.")
        sys.exit(1)

    save_spec_cache(spec_content, current_hash)
    generate_models(current_hash)

    print("\nGeneration complete!")


if __name__ == "__main__":
    main()
